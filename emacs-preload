#!/usr/bin/env python3

# emacs-preload: Fast Emacs Startup by Preloading Emacs Servers
# Copyright (C) 2017  Michael D. Adams <https://michaeldadams.org/>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import base64
import collections
import contextlib
import distutils.util
import functools
import hashlib
import inspect
import os
import pathlib
import re
import shlex
import signal
import stat
import subprocess
import sys
import tempfile
import textwrap
import time
import traceback

# NOTE: the sha1 in __version__ can be computed manually with:
#   openssl dgst -sha1 emacs-preload
# NOTE: we use getsourcefile instead of __file__ to avoid .pyc files
__version__ = '0.1.1 (sha-1: ' + str(base64.b16encode(hashlib.sha1(pathlib.Path(inspect.getsourcefile(
    lambda: None)).read_bytes()).digest()), encoding='utf-8') + ')'

# Configuration variables.  Set by command line flags or environment variables.
ENV_PREFIX = 'EMACS_PRELOAD_'
def configs():
    # These two lines mirror code in Emacs's `server.el`
    link_dir = os.path.expanduser('~/.emacs.d/preload')
    socket_dir = or_none(os.getenv('TMPDIR'), '/tmp') + '/emacs' + str(os.geteuid())
    return [
        ('DRY_RUN', False, 'Print commands instead of executing them'),
        ('QUIET', False, 'Supress info messages and startup messages from emacs servers'),
        ('QUERY_EMACS', False, 'Call emacs to determine LINK_DIR and SOCKET_DIR.'
         + ' Off by default for performance.'),
        ('SIZE', ('SIZE', 7), 'Number of servers to keep running (see `start` and `stop`)'),
        ('INIT_HOOK', ('PROG', ''), 'User hook. Called by `init` with the link directory as argument. Ignored if empty string'),
        ('START_HOOK', ('PROG', ''), 'User hook. Called by `start` with the socket file as argument. Ignored if empty string.'),
        ('CONNECT_HOOK', ('PROG', ''), 'User hook. Called by `connect` with the socket file as argument. Ignored if empty string.'),
        ('STOP_HOOK', ('PROG', ''), 'User hook. Called by `stop` with the socket file as argument. Ignored if empty string.'),
        ('EMACS', ('FILE', 'emacs'), 'The emacs binary to use'),
        ('EMACSCLIENT', ('FILE', 'emacsclient'), 'The emacsclient binary to use'),
        ('PS', ('FILE', 'ps'), 'The ps binary to use for process listing'),
        ('PATCH_SERVER', True, 'Patch the emacs server to remove the quirks of server mode'),
        ('START_DELAY', 0.1, 'Seconds to wait between starting servers'),
        ('STOP_DELAY', 0.1, 'Seconds to wait between stopping servers'),
        ('KILL_DELAY', 1.0, 'Seconds to wait between SIGTERM and SIGKILL when killing servers'),
        ('CONNECT_DELAY', 0.1, 'Seconds between attempts to connect to a server'),
        ('CONNECT_ATTEMPTS', 100, 'Maximum number of attempts to connect to a server'),
        ('CONNECT_TIMEOUT', 10.0, 'Maximum seconds to keep attempting to connect to a server'),
        ('PREFIX', 'preload-', 'Prefix to use for server names, links, and sockets'),
        ('LINK_DIR', ('DIR', link_dir), 'Directory in which to place links'),
        ('SOCKET_DIR', ('DIR', socket_dir), 'The directory in which emacs stores its sockets')]

################
# Errors

class Err(Exception):
    def __init__(self, lineno, message):
        Exception.__init__(self)
        self.message = f('[#{}] {}', lineno, message)

def error(message, *args, **kwargs):
    raise Err(lineno(3), f(message, *args, **kwargs))

def check(val, message, *args, **kwargs):
    if val: return val
    else: raise Err(lineno(3), f(message, *args, **kwargs))

def lineno(back, stack=None):
    current = os.path.abspath(__file__)
    if stack is None:
        stack = traceback.extract_stack()
    frames = [f for f in stack if current == os.path.abspath(f.filename)]
    return frames[-back].lineno # innermost is last in list

def because(m1, m2): return f('{}\n    because {}', m1, m2)

@contextlib.contextmanager
def noop(): yield

class MuteErr (Exception): pass
@contextlib.contextmanager
def mute():
    try: yield
    except MuteErr: pass

@contextlib.contextmanager
def err(message, *args, **kwargs):
    err_lineno = lineno(3)
    try: yield
    except Err as e:
        raise Err(err_lineno, because(f(message, *args, **kwargs), e.message))
    except Exception as e:
        (_, _, tb) = sys.exc_info()
        exc_lineno = lineno(1, stack=traceback.extract_tb(tb))
        raise Err(err_lineno, because(f(message, *args, **kwargs), Err(exc_lineno, str(e)).message))

@contextlib.contextmanager
def warn(message, *args, **kwargs):
    err_lineno = lineno(3)
    try: yield
    except Err as e:
        log(Err(err_lineno, because(f(message, *args, **kwargs), e.message)).message, file=sys.stderr)
    except Exception as e:
        (_, _, tb) = sys.exc_info()
        exc_lineno = lineno(1, stack=traceback.extract_tb(tb))
        log(Err(err_lineno, because(f(message, *args, **kwargs), Err(exc_lineno, str(e)).message)).message, file=sys.stderr)

################
# Execution control

# Implements dry runs.  Calls fun(*args, **kwargs) if DRY_RUN is false.
# Otherwise, prints the function and arguments that would be called.
def dry(fun, *args, **kwargs):
    if DRY_RUN: log('skipping due to dry run: {} on {} with {}', fun.__name__, args, kwargs)
    else: fun(*args, **kwargs)

# Used by commands that cannot dry-run.  Throws error if DRY_RUN is true.
def not_dry(c):
    if DRY_RUN: error('Dry run not supported by {}', c)

# Run the process described by `args`
def cmd(*args, replace=False, stdin=subprocess.DEVNULL, stdout=subprocess.PIPE, stderr=None, dry_run=False):
    if dry_run and DRY_RUN:
        log('skipping due to dry run: {}', ' '.join(map(shlex.quote, args)))
        return None
    elif replace:
        os.execvp(args[0], args)
    else:
        with err('process failed: {}', ' '.join(map(shlex.quote, args))):
            r = subprocess.run(args,
                stdin=stdin, stdout=stdout, stderr=stderr, universal_newlines=True)
            check(r.returncode == 0, 'process returned exit code {}', r.returncode)
        return r.stdout

##################
# Generic helpers

# `None` aware `or`
def or_none(x, y): return x if x is not None else y

# Simulate f"..." strings for Python 3.5
def f(s, *args, **kwargs): return s.format(*args, **kwargs)

# Print a log message with the 'emacs-preload' prefix
def log(s, *args, **kwargs): print(f('emacs-preload: {}', f(s, *args, **kwargs)))

# Print info messages, but only if QUIET is false.
def info(s, *args, **kwargs):
    if not QUIET:
        log(s, *args, **kwargs)

# Parse strings as booleans
true_strings = ['y', 'yes', 't', 'true', 'on', '1']
false_strings = ['n', 'no', 'f', 'false', 'off', '0']
def parse_bool(value):
    # These true and false values mirror `distutils.util.strtobool`
    if isinstance(value, bool):
        return value
    elif value.lower() in true:
        return True
    elif value.lower() in false:
        return False
    else:
        error('invalid truth value \'{}\'\n'
            '        for True use one of {}\n'
            '        for False use one of {}\n'
            '        both are case insensitive',
            value, or_str(true), or_str(false))

# Combine `parts` according to English grammar rules
def or_str(parts, prefix='\'', postfix='\''):
    parts = [prefix+p+postfix for p in parts]
    if len(parts) == 0:
        raise ValueError('empty list passed to or_str')
    elif len(parts) == 1:
        return parts[0]
    elif len(parts) == 2:
        return f('{} or {}', parts[0], parts[1])
    else:
        return ', '.join(parts[:len(parts)-1]) + ', or ' + parts[-1]

# Wrap lines to terminal width but recognize '\n\n' as a paragraph separator
def wrap_lines():
    # Taken from argparse.HelpFormatter.__init__
    # NOTE: COLUMNS is usually not set
    try: width = int(os.environ['COLUMNS'])
    except (KeyError, ValueError): width = 80
    width -= 2
    # Taken from argparse.HelpFormatter._format_text
    width = max(width, 11)

    def doc(d, *args, **kwargs):
        paragraphs = [textwrap.fill(re.sub('\n\s*', ' ', p.strip()), width)
            for p in f(d, *args, **kwargs).split('\n\n')]
        return '\n\n'.join(paragraphs)
    return doc

# Forces the arguments of ArgumentParser `c` to never be options
def literal_args(c):
    if len(c._actions) > 0:
        old_parse = c.parse_known_args
        def new_parse(args=None, namespace=None):
            return old_parse(['--']+or_none(args, []), namespace)
        c.parse_known_args = new_parse

# `DirEntry` returned by os.scandir are more trouble than they are worth, so
# just return the path
def scandir(path): return [p.path for p in os.scandir(path)]

# Return true if `socket` exists and is a socket
def is_socket(socket): return os.path.exists(socket) and stat.S_ISSOCK(os.stat(socket).st_mode)

# List the PID and command string of processes starting with `prefix`
def pgrep(prefix):
    with err('failed to get running processes'):
        with err('failed to get list of all processes'):
            output = cmd(PS, '-u', str(os.geteuid()), '-o', 'pid=,command=')
        for line in output.strip().split('\n'):
            with err('failed to parse process information line {}', line):
                [pid, proc] = line.split(maxsplit=1)
            if proc.startswith(prefix):
                yield (pid, proc)

######################
# Domain-specific helpers

# Evaluate an elisp expression
def elisp(code): return cmd(EMACS, '--batch', '--eval', code, stderr=subprocess.DEVNULL)

# Run `emacsclient` with a given socket.  Note that accepts both absolute and
# relative paths because `emacsclient` already supports that.
def emacs_cl(socket, *args, **kwargs):
    return cmd(EMACSCLIENT, '--quiet', '--socket-name', socket, *args, **kwargs)

# Prefix that server processes start with in `ps`
def server_prefix(): return f('{} --daemon=', EMACS)

# Prefix striped from server processes in `ps` to get the socket name
def server_socket_prefix(): return f('{}{}', server_prefix(), SOCKET_DIR)

# Prefix that client proceses start with in `ps`
def client_prefix(): return f('{} --quiet --socket-name ', EMACSCLIENT)

# Prefix striped from client processes in `ps` to get the socket name
def client_socket_prefix(): return f('{}{}', client_prefix(), SOCKET_DIR)

# Convert a link path to a socket path
def socket_from_link(link):
    with err('failed to follow link {}', link):
        socket = os.path.join(os.path.dirname(link), os.readlink(link))
    expected = os.path.abspath(os.path.join(SOCKET_DIR, os.path.basename(link)))
    actual = os.path.abspath(socket)
    check(expected == actual,
        'expected path {} does not match actual path {}', expected, actual)
    return socket

# Generator that lists available preload links
def links(non_links=False):
    with err(f('failed to list preload links in ', LINK_DIR)):
        # NOTE: lazy generator because `claim_socket` needs only one
        for link in scandir(LINK_DIR):
            if os.path.basename(link).startswith(PREFIX):
                if non_links or os.path.islink(link):
                    yield link

# Returns number of available preload links
def link_count():
    with err('failed to count preload links'):
        return len(list(links()))

# Returns number of clients connected to the server at `socket`
def client_count(socket):
    with err('failed to determine client count'):
        with err('failed to connect to server at socket {}', socket):
            count_str = emacs_cl(socket, '--eval', '(princ (length server-clients))')
        with err('server returned non-integer count {}', count_str):
            count_int = int(count_str)
        return count_int - 1 # subtract one to not count ourselves

# Generator that lists available preload sockets
def sockets(non_sockets=False):
    with err(f('failed to list preload sockets in {}', SOCKET_DIR)):
        for socket in scandir(SOCKET_DIR):
            if os.path.basename(socket).startswith(PREFIX):
                if non_sockets or is_socket(socket):
                    yield socket

# Parse the `size` argument to `start` and `stop`
def preload_size(s, default):
    with err(f('failed to parse preload size `{}`', s)):
        if s is None:
            i = default
        elif re.fullmatch('\\+[0-9]+', s) is not None:
            i = link_count() + int(s[1:])
        elif re.fullmatch('\\-[0-9]+', s) is not None:
            i = link_count() - int(s[1:])
        elif re.fullmatch('[0-9]+', s) is not None:
            i = int(s)
        else:
            error('invalidly formatted size `{}`', s)

        if i >= 0: return i
        else:
            info('using zero instead of negative size {}', i)
            return 0

# Reserve a server and its socket for our use as a client
def claim_socket():
    with err('failed to claim a socket file'):
        files = links()
        try: link = next(files)
        except StopIteration as e:
            error('no links available in {}', LINK_DIR)
        socket = socket_from_link(link)
        try: dry(os.remove, link)
        except Exception as e:
            if os.path.exists(link):
                error(because(f('failed to remove link {}', link), str(e)))
            else:
                error(because(f('missing link {}', link), str(e)))
        count = client_count(socket)
        check(count == 0,
            'socket already has clients ({})', count)
        return socket

################################
# Subcommands

# Check for errors in the current state
def check_status(args): status(args, verbose=False)

# Print server status
def status(args, verbose=True):
    # Print status of `strings` which is expected to be `expected_prefix` followed by the name
    def print_status(string, expected_prefix, require_link=True):
        # If something goes wrong, we need to continue checking the status of
        # other things, so we have local versions of `check` and `err` for that.
        def _check(test, message, *args, **kwargs):
            nonlocal errs
            if not test:
                print(f('!!! error: {}', f(message, *args, **kwargs)))
                errs += 1
                raise MuteErr()

        @contextlib.contextmanager
        def _err(*args, **kwargs):
            try: yield
            except Exception: _check(False, *args, **kwargs)

        # Local version of _info that pays attention to `verbose`
        def _info(s, *args, **kwargs):
            if verbose:
                print(f(s, *args, **kwargs))

        if not string.startswith(f('{}/{}', expected_prefix, PREFIX)):
            # Right type of thing, but not from `emacs-preload`
            _info('    warn: not recognized')
            print(f('status: ignored'))
            print()
            return

        errs = 0
        name = string[len(expected_prefix + '/'):].split(' ')[0]

        link = os.path.abspath(os.path.join(LINK_DIR, name))
        socket = os.path.abspath(os.path.join(SOCKET_DIR, name))

        _info('    name: {}', name)

        with mute():
            _check(name.startswith(PREFIX),
                'name does not match {}PREFIX ({}): {}', ENV_PREFIX, PREFIX, name)

            # Links
            with mute():
                if not os.path.lexists(link):
                    _check(not require_link,
                        'link does not exist: {}', link)
                else:
                    _info('    link: {}', link)
                    _check(os.path.islink(link),
                        'file not a link: {}', link)
                    with _err('could not follow link: {}', link):
                        target = os.path.abspath(socket_from_link(link))
                    _check(socket == target,
                         'socket ({}) does not match link target ({})', socket, target)

            # Sockets
            with mute():
                _check(os.path.exists(socket),
                    'socket does not exist: {}', socket)
                _info('    socket: {}', socket)
                _check(is_socket(socket),
                    'file not a socket: {}', socket)

            # Servers
            with mute():
                server_string = f('{}{}/{}', server_prefix(), SOCKET_DIR, name)
                num_servers = 0
                for (pid, proc) in servers:
                    if proc.startswith(server_string):
                        _info('    server: pid {}: {}', pid, proc)
                        num_servers += 1
                _check(num_servers == 1,
                    '{} servers but expected 1', num_servers)

            with mute():
                with _err('failed to connect to server at {}', socket):
                    count_str = emacs_cl(socket, '--eval', '(princ (length server-clients))',
                        stderr=subprocess.DEVNULL)
                with _err('server returned non-integer count {}', count_str):
                    count_int = int(count_str)
                _info('    reported clients: {}', count_int - 1)

            # Clients
            client_string = client_prefix() + socket
            for (pid, proc) in clients:
                if proc.startswith(client_string):
                    _info('    client: pid {}: {}', pid, proc)

        print(f('status: {} errors', errs))
        print()

    print('Version')
    print('------------------------')
    print('emacs-preload:')
    print(__version__)
    print()
    print('python:')
    print(sys.version)
    print()
    print('emacs:')
    try: print(cmd(EMACS, '--version'))
    except Err as e: print(e.message)
    print()
    print('emacsclient:')
    try: print(cmd(EMACSCLIENT, '--version'))
    except Err as e: print(e.message)
    print()

    print('Configuration variables')
    print('------------------------')
    for (name, _, _) in configs():
        print(f('{}{}={}', ENV_PREFIX, name, shlex.quote(str(globals()[name]))))
    print()

    links = []
    with warn('failed to read link directory {}', LINK_DIR):
        links = list(scandir(LINK_DIR))

    sockets = []
    with warn('failed to read socket directory {}', SOCKET_DIR):
        sockets = list(scandir(SOCKET_DIR))

    servers = []
    with warn('failed to list servers'):
        servers = list(pgrep(server_prefix()))

    clients = []
    with warn('failed to list clients'):
        clients = list(pgrep(EMACSCLIENT))

    print(f('Links in {} ({})', LINK_DIR, len(links)))
    print('------------------------')
    for link in links:
        print(f('{}:', link))
        print_status(link, LINK_DIR)
    print()

    print(f('Sockets in {} ({})', SOCKET_DIR, len(sockets)))
    print('------------------------')
    for socket in sockets:
        print(f('{}:', socket))
        print_status(socket, SOCKET_DIR, require_link=False)
    print()

    print(f('Servers ({})', len(servers)))
    print('------------------------')
    for (pid, command) in servers:
        print(f('{}:', command))
        print(f('    pid: {}', pid))
        print_status(command, server_socket_prefix(), require_link=False)
    print()

    print(f('Clients ({})', len(clients)))
    print('------------------------')
    for (pid, command) in clients:
        print(f('pid {}: {}', pid, command))
        print_status(command, client_socket_prefix(), require_link=False)
    print()

# Start emacs servers
def start(args):
    not_dry('start')
    init(args)
    size = preload_size(args.size, SIZE)
    while link_count() < size:
        info('creating server (have {}, want {})', link_count(), size)
        with err('failed to create socket file in {}', SOCKET_DIR):
            (fd, socket) = tempfile.mkstemp(dir=SOCKET_DIR, prefix=PREFIX)
            os.close(fd)
        with err('failed to create emacs server for socket file {}', socket):
            cmd(EMACS, '--daemon='+socket,
                stdout=subprocess.DEVNULL if QUIET else None,
                stderr=subprocess.DEVNULL if QUIET else None)
        with err('failed to create link from {} to socket {}', LINK_DIR, socket):
            os.symlink(socket, os.path.join(LINK_DIR, os.path.basename(socket)))
        # Patch the server to behave more like emacs instead of emacsclient
        if PATCH_SERVER:
            with err('failed to patch emacs server'):
                emacs_cl(socket, '--eval', '''
                    (progn
                        (require 'server)
                        ;; C-x C-c should actually kill emacs instead of just the client
                        (defun server-save-buffers-kill-terminal (arg)
                            (save-buffers-kill-emacs arg))
                        ;; Don't prompt user about clients when killing buffers
                        (remove-hook 'kill-buffer-query-functions
                            'server-kill-buffer-query-function)
                        ;; Don't prompt user about clients when killing emacs
                        (remove-hook 'kill-emacs-query-functions
                            'server-kill-emacs-query-function)
                        ;; Don't exit when all buffers closed.
                        ;; defun instead of remove-hook due to add-hook called on every buffer
                        (defun server-kill-buffer () nil)
                    )''')
        if START_HOOK != '':
            with err('failed running START_HOOK: "{}" "{}"', START_HOOK, socket):
                cmd(START_HOOK, socket, stdout=None, stderr=None, dry_run=True)
        time.sleep(START_DELAY)
    info('done creating servers (have {}, want {})', link_count(), size)

# Stop emacs servers
def stop(args):
    not_dry('stop')
    size = preload_size(args.size, 0)
    while link_count() > size:
        info('stopping server (have {}, want {})', link_count(), size)
        socket = claim_socket()
        if STOP_HOOK != '':
            with err('failed running STOP_HOOK: "{}" "{}"', STOP_HOOK, socket):
                cmd(STOP_HOOK, socket, stdout=None, stderr=None, dry_run=True)
        with err('failed to send (kill-emacs) to server at {}', socket):
            emacs_cl(socket, '--eval', '(kill-emacs)')
        # Delay needed so servers after the first shutdown cleanly.
        # Though I don't know why.
        time.sleep(STOP_DELAY)
    info('done stopping servers (have {}, want {})', link_count(), size)

# Connect to a server
def connect(args):
    start_time = time.time()
    attempts = 0
    while True:
        attempts += 1
        elapsed_time = time.time() - start_time
        if attempts > CONNECT_ATTEMPTS:
            error('failed to connect after at least {} attempts', CONNECT_ATTEMPTS)
        if elapsed_time > CONNECT_TIMEOUT:
            error('failed to connect after at least {} seconds', CONNECT_TIMEOUT)
        try:
            socket = claim_socket()
        except Err as e:
            time.sleep(CONNECT_DELAY)
        else:
            # TODO: anything other than PWD we need to set?
            with err('failed to set PWD on server at {}', socket):
                # String escape PWD in case it contains special characters
                cwd = ''.join([f('\\x{:02X}', ord(c)) for c in os.getcwd()])
                emacs_cl(socket, '--eval', f('(setenv "PWD" "{}")', cwd),
                    dry_run=True, stdin=None, stdout=subprocess.DEVNULL)
            if CONNECT_HOOK != '':
                with err('failed running CONNECT_HOOK: "{}" "{}"', CONNECT_HOOK, socket):
                    cmd(CONNECT_HOOK, socket, stdout=None, stderr=None, dry_run=True)
            with err('failed to connect to server at {}', socket):
                emacs_cl(socket, '--create-frame', *args.args,
                    replace=True, stdin=None, stdout=None, stderr=None, dry_run=True)
            # `emacs_cl(..., replace=True, ...) does a Unix `exec`, so it is
            # an error if we get to this line.
            raise Exception('returned from exec')

# Cleanup broken servers
def cleanup(args):
    socket_map = {}
    # Remove link if cannot connect or server already in use
    for link in links(non_links=True):
        if not os.path.islink(link):
            info('skipping non-link {}', link)
        else:
            try:
                socket = socket_from_link(link)
                clients = client_count(link)
                check(clients > 0,
                    'already in use by {} clients', clients)
                socket_map[socket] = link
            except Err as e:
                info(because(f('removing link {}', link), e.message))
                with err(f('failed to remove link {}', link)):
                    dry(os.remove, link)

    # Remove socket if no link and either cannot connect or no clients
    # currently connected
    for socket in sockets(non_sockets=True):
        if socket in socket_map:
            info('skipping socket {} due to having link {}', socket, socket_map[socket])
        elif not is_socket(socket):
            info('skipping non-socket {}', socket)
        else:
            try:
                clients = client_count(socket)
            except Err as e:
                info(because(
                    f('removing socket at {} due to no connection to the server', socket),
                    e.message))
                with err('failed to remove socket {}', socket):
                    dry(os.remove, socket)
            else:
                if clients == 0:
                    info('sending (kill-emacs) to server at {}'
                        ' due to having no link and no clients', socket)
                    with err('failed to (kill-emacs) on server at {}', socket):
                        emacs_cl(socket, '--eval', '(kill-emacs)', dry_run=True)
                    # Delay needed so servers after the first shutdown cleanly.
                    # Though I don't know why.
                    time.sleep(STOP_DELAY)

# Kill running servers
def kill_servers(orphans_only, args):
    for sig in [signal.SIGTERM, signal.SIGKILL]:
        with err('failed to list servers'):
            servers = pgrep(f('{}/{}', server_socket_prefix(), PREFIX))
        for (pid, command) in servers:
            pid = int(pid)
            socket = command[len(server_prefix()):]
            if not orphans_only or not is_socket(socket):
                info('sending {} to emacs server (pid {}, socket {})', sig.name, pid, socket)
                with err('failed to send {} to emacs server (pid {}, socket {})', sig.name, pid, socket):
                    dry(os.kill, pid, sig)
        time.sleep(KILL_DELAY)
    with err('failed to list servers'):
        servers = list(pgrep(f('{}/{}', server_socket_prefix(), PREFIX)))
        print(f('servers still running: {}', len(servers)))
        for (pid, command) in servers:
            print(f('PID {}: {}', pid, command))


# Combines `connect` with `start` in the background
def run(args):
    not_dry('run')
    if not hasattr(args, 'size'):
        args.size = None

    # Run `start` in a background process
    with err('failed to fork background process for `start`'):
        pid = os.fork()
    if pid == 0:
        with err('failed to create background process for `start`'):
            with err('failed to detach'):
                os.setsid() # Detach from the parent process and terminal
            with err('failed to fork'):
                pid = os.fork()
            if pid == 0:
                with err('failed to change to root directory'):
                    os.chdir('/') # Avoid holding directories open
                globals()['QUIET'] = True # Silence everything except errors
                start(args)
            else:
                sys.exit(0)
    else:
        with err('failed waiting on child process for `start`'):
            os.waitpid(pid, 0) # Avoid zombie process from outer fork
        connect(args)

# Create the directory for links to servers
def init(args):
    if INIT_HOOK != '':
        with err('failed running INIT_HOOK: "{}" "{}"', INIT_HOOK, socket):
            cmd(INIT_HOOK, socket, stdout=None, stderr=None, dry_run=True)
    with err('failed to create preload link directory {}', LINK_DIR):
        dry(os.makedirs, LINK_DIR, exist_ok=True)

################
# Initialization and driver

# Parse command-line arguments
def parse_args():
    ################################
    # Constants

    doc = wrap_lines()

    args_help = f('''Arguments to `emacsclient`.  Not parsed by `emacs-preload`.  Passed unchanged to `emacsclient`.''')

    def size_help(size):
        return f('''Target number of servers to have running.  Defaults to {} if omitted.
            Relative when starts with `+` or `-`.  Absolute otherwise.''', size)

    cleanup_doc = '''Normally emacs-preload cleans up after itself automatically.  If it
            doesn't, you can use this command to manually cleanup.  We are
            working to reduce how often this command is needed.'''

    def kill_doc(servers, commands):
        return f('''{}

            WARNING: Disconnects any `emacsclient` connected to {} preload
            servers.  This is not part of `stop` or `cleanup` since there is
            no way to tell if the servers skipped by `cleanup` have connected
            clients.  This command should only be used when {} to fail to
            shutdown a server.''',
            cleanup_doc, servers, commands)

    def help_description():
        string = ''
        string += 'Prints help for the given subcommand or topic\n'
        string += '\n'
        string += 'subcommands:\n'

    ################################
    # Argument parser

    # NOTE: we do not support the '@file' convention because arguments to
    # subcommand must be passed unchanged.  Thus no `fromfile_prefix_chars`
    # argument to `ArgumentParser`
    p = argparse.ArgumentParser(usage='%(prog)s [options] <subcommand> ...',
        add_help=False, formatter_class=argparse.RawDescriptionHelpFormatter,
        description=doc('''
            # Emacs Preload: Fast Emacs Startup by Preloading Emacs Servers

            This program is a drop-in replacement for Emacs that reduces start
            times by preloading Emacs server instances in the background.

            ## Examples

            If you do not care about the details, just use `emacs-preload run`
            instead of `emacs`, and the tool will take care of the test.

            The first run after a boot will be as slow as a normal `emacs`
            startup as there are no servers preloaded yet.  After that, the
            pool is automatically repopulated, and later runs should be much
            faster.

            You can avoid this initial slowness by populating the server pool
            in advance with `emacs-preload start`.  In fact, `run` populates
            the pool by running `start` in the background.

            Any argument that can be passed to `emacsclient` is accepted.
            Common use cases include:

            - `emacs-preload run`

            - `emacs-preload run -nw`

            - `emacs-preload run file.txt`

            An invocation of the form `emacs-preload run <args ...>`
            corresponds to the following where `<name>` is internally
            determined by `emacs-preload`:

            - `emacsclient --quiet --socket-name <name> --create-frame <args ...>`

            **Note:** Optional argument (a.k.a. flags) passed to
            `emacs-preload` must occur *before* the subcommand.  Anything
            afterwards is passed to the subcommand unchanged.  This is so that
            arguments to commands like `emacs-preload run` are not
            intercepted.

            For more details about this program visit the project home page at
            <https://bitbucket.org/adamsmd/emacs-preload>.

            ## Configuration

            Any of the following optional arguments can also be configured by
            setting an environment variable.  For example, both the
            `--start-delay` option and the `{}START_DELAY` environment
            variable set the `START_DELAY` to be used.  When both are set,
            optional arguments override environment variables.

            For environment variables, `y`, `yes`, `t`, `true`, `on`, and `1`
            are interpreted as true, and `n`, `no`, `f`, `false`, `off`, and
            `0` are interpreted as false.  These are all case insensitive.
            ''',
            ENV_PREFIX))
# TODO: override add_argument_group to get '#' headers on optional arguments and subcommands
# TODO: allow path to python3 to be configured

    ################################
    # Options
    p.add_argument('-h', '--help', action='help', help='Show this help message and exit')
    c = p.add_argument('-v', '--version', action='version',
        version=f('emacs-preload version {}', __version__),
        help='Show program\'s version number and exit')
    for (key, default_value, documentation) in configs():
        # Extract the manually defined metavar if there is any
        if isinstance(default_value, tuple):
            metavar = default_value[0]
            default_value = default_value[1]
        # Otherwise, name the metavar after the type
        else:
            metavar = type(default_value).__name__.upper()

        value = default_value

        # Determine default value and add to documentation
        env_value = os.getenv(f('{}{}', ENV_PREFIX, key))
        if env_value is None:
            # Environment does not override default
            documentation += f(' (default \'{}\')', value)
        else:
            # Environment does override default
            documentation += f(' (default \'{}\' but environment overrides to \'{}\')', value, env_value)
            value = env_value

        name=key.lower().replace('_', '-')

        # Simple Boolean flags
        if isinstance(default_value, bool):
            p.add_argument(f('--{}', name), default=value, action='store_true', dest=key, help=documentation)
            p.add_argument(f('--no-{}', name), default=value, action='store_false',
                dest=key, help=f('Disable --{}', name))
        # Options with arguments
        else:
            p.add_argument(f('--{}', name), metavar=metavar, action='store', dest=key,
                default=value, help=documentation)

    ################################
    # Subcommands
    s = p.add_subparsers(title='subcommands', dest='subcommand')
    s.required = True # Workaround for bug in `argparse` (as of Python 3.5)
    subcommands=collections.OrderedDict() # OrderedDict so printed in a consistent order

    def subcommand(func, name=None, description=None, **kwargs):
        if name is None:
            name = func.__name__
        name = name.replace('_', '-')

        c = s.add_parser(name, prog=f('emacs-preload [options] {}', name), description=description,
            add_help=False, formatter_class=argparse.RawDescriptionHelpFormatter, **kwargs)
        c.set_defaults(action=func)
        kwargs['subcommand'] = c
        subcommands[name] = kwargs
        return c

    c = subcommand(run,
        help='''Main `emacs-preload` subcommand.  Connect to a preload server and in the
            background start new servers.''',
        description=doc('''Main `emacs-preload` subcommand. Uses `connect` to connect to an available
            preload server, while using `start` in the background to launch new servers.

            NOTE: Depending on how the `connect` and `start` processes are
            scheduled, the number of servers left running may be one fewer
            than specified.'''))
    c.add_argument('args', nargs='*', help=args_help)

    c = subcommand(check_status, name='check', help='Check for errors',
        description=doc('''Print preload configuration and check for errors in links, sockets, servers, or clients.'''))

    c = subcommand(start, help='Start preload servers',
        description=doc('''Start new preload servers until at least `size` servers are running.'''))
    c.add_argument('size', nargs='?', help=size_help(f('`SIZE`')))

    c = subcommand(stop, help='Stop preload servers',
        description=doc('''Stop running preload servers until at most `size` servers are running.'''))
    c.add_argument('size', nargs='?', help=size_help(f('zero')))

    c = subcommand(status, help='Print preload status',
        description=doc('''Print status of preload configuration, links, sockets, servers, and clients.'''))

    c = subcommand(init, help='Create the directory holding links to preload servers',
        description=doc('''Create the directory specified by `LINK_DIR`, which is where links to
            preload servers are kept.

            Rarely needs to be called manually as it is automatically called
            by the subcommands that need the `LINK_DIR` directory.'''))

    c = subcommand(connect, help='Connect to a preload server',
        description=doc('''Connect to an available preload server.  Picks a waiting server from those
            in `LINK_DIR`, removes it from `LINK_DIR`, and connects to it with
            `emacsclient`.'''))
    c.add_argument('args', nargs='*', help=args_help)

    c = subcommand(cleanup, help='Cleanup broken servers',
        description=doc('''Cleanup broken servers.

            {}

            This command is always safe.  It will not close servers with
            connected clients or fresh servers waiting for a client.  Because
            this subcommand is guaranteed to be safe, it leaves alone servers
            for which it cannot confirm that there are no clients.  Thus you
            may need to use kill-orphans or kill-all subcommands to kill such
            servers.

            Removes links in `LINK_DIR` for unreachable servers and servers
            that already have clients.  Removes sockets in `SOCKET_DIR` that
            do not connect to a server.  Sends `(kill-emacs)` to servers that
            have no client and are not in `LINK_DIR`.''', cleanup_doc))


    c = subcommand(functools.partial(kill_servers, True), name='kill-orphans', help='Kill orphaned servers',
        description=doc('''Kills all orphan preload servers, which are those for which there are no
            sockets in `SOCKET_DIR`.

            {}''', kill_doc('orphan', '`cleanup`')))

    c = subcommand(functools.partial(kill_servers, False), name='kill-all', help='Kill all servers',
        description=doc('''Kills all preload servers.

            {}''', kill_doc('', '`cleanup` and `kill-orphans`')))

    # TODO: document code
    def export_usage(args):
        with err('error while writing to {}', args.file), \
             open(args.file, 'w') as file, \
             contextlib.redirect_stdout(file):
            print('# Usage')
            print()
            print('Usage: `emacs-preload [options] <subcommand> ...`')
            print()
            print('**Note:** Do not edit this file directly.  It is generated by `emacs-preload export-usage`.')
            print()
            print(p.description)
            print()
            print('optional arguments: |')
            print('----|----')
            for action in p._actions:
                if action.help is not None:
                    print(f('{} {} | {}',
                        ', '.join(action.option_strings),
                        or_none(action.metavar, ''),
                        action.help))
            print()
            print('subcommands: |')
            print('----|----')
            for key in subcommands:
                print(f('{} | {}', key, re.sub('\n\s*', ' ', subcommands[key]['help'])))
            print()

            for key in subcommands:
                print()
                value = subcommands[key]
                print(f('## {}', key))
                print()
                args = ''
                if 'nargs' in value:
                    for action in value['nargs']:
                        form = \
                            ' {}' if action.nargs is None else \
                            ' [{}]' if action.nargs == '?' else \
                            ' [{0} [{0} ...]' if action.nargs == '*' else \
                            None
                        args += f(form, action.dest)
                print(f('Usage: `{}{}`', value['subcommand'].prog, args))
                if value['subcommand'].description is not None:
                    print()
                    print(f('{}', value['subcommand'].description))
                if value['subcommand']._actions != []:
                    print()
                    print(f('Arguments | '))
                    print(f('----------|-'))
                    for action in value['subcommand']._actions: # TODO: public api?
                        print(f('`{}` | {}', action.dest, re.sub('\n\s*', ' ', action.help)))

    c = subcommand(export_usage, help='Generate Markdown version of usage messages',
        description=doc('''Generate Markdown version of usage messages'''))
    c.add_argument('file', nargs='?', default='Usage.md',
        help='The file in which to put the usage messages')

    def help(args):
        if args.subcommand is None:
            subcommands['help']['subcommand'].print_help()
        elif args.subcommand in subcommands:
            subcommands[args.subcommand]['subcommand'].print_help()
        else:
            error('no subcommand {}. ', args.subcommand)

    # Last so we can get a list of all subcommands and topics
    c = subcommand(help, help='Prints help for subcommands', description=help_description())
    c.add_argument('subcommand', metavar='subcommand', nargs='?', choices=subcommands.keys(), action='store',
        help=f('The subcommand for which to print help (choose from {})', or_str(subcommands.keys(), prefix='`', postfix='`')))

    ################################
    # Subcommand arguments

    # Arguments to `connect` and `run` are passed on to `emacsclient`.  So we
    # do not parse them.  For consistency, we do this for all subcommands.
    for c in subcommands.values(): literal_args(c['subcommand'])

    return p.parse_args()

################################
# Main program
def main():
    try:
        # Parse command line
        args = parse_args()

        # Initialize global variables
        for (key, default_value, _) in configs():
            if isinstance(default_value, tuple):
                default_value = default_value[1]
            value = vars(args)[key]
            with err('could not parse {}: {}', key, value):
                globals()[key] = parse_bool(value) if isinstance(default_value, bool) else type(default_value)(value)

        if QUERY_EMACS:
            with err('failed to query emacs for LINK_DIR'):
                globals()['LINK_DIR'] = elisp(
                    '(princ (expand-file-name (locate-user-emacs-file "preload")))')
            with err('failed to query emacs for SOCKET_DIR'):
                globals()['SOCKET_DIR'] = elisp(
                    '(progn (require \'server) (princ (expand-file-name server-socket-dir)))')

        # Run the selected subcommand
        args.action(args)

    # Catch only Err exceptions.  Other exceptions are bugs, so we leave them uncaught.
    except Err as e:
        log(e.message, file=sys.stderr)
        sys.exit(1)
    sys.exit(0)

if __name__ == '__main__':
    main()
