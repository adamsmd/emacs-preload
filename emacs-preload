#!/usr/bin/env python3

import argparse
import base64
import collections
import contextlib
import distutils.util
import functools
import hashlib
import inspect
import os
import pathlib
import re
import shlex
import signal
import stat
import subprocess
import sys
import tempfile
import textwrap
import time
import traceback

# NOTE: the sha1 in __version__ can be computed manually with:
#   cat emacs-preload | openssl dgst -binary -sha1 | openssl base
# NOTE: getsourcefile instead of __file__ to avoid .pyc files
__version__ = '0.1 (sha1 ' + str(base64.b64encode(hashlib.sha1(pathlib.Path(inspect.getsourcefile(
    lambda: None)).read_bytes()).digest()), encoding='utf-8') + ')'

# emacs-preload
#
# This file is `emacs-preload`, which manages a pool
# of emacs daemons for fast emacs

# emacs-preload
#
# maintains a pool of emacs deamons for fast emacsclient startup
#
# The most common usage is simply:
#   emacs-preload connect ARGS ...
# where ARGS are arguments to be passed to `emacsclient` (e.g., files to edit).

# Data structures:
#  ~/.emacs.d/preload/preload-XXXX
#  /tmp/emacs1000/preload-XXXX
#  emacs server

# Technical details:
# Emacs deamons put a socket file in `/tmp/emacs$UID/$NAME`
# This script puts in ~/.emacs.d/preload/ symlinks to the socket fild of the servers it starts.
# When this script connects to a server, it removes that symlink
# Thus all the symlinks in ~/.emacs.d/preload/ represent unused servers that we can connect to.
#
# When the number of symlinks in ~/.emacs.d/preload/ is low,
# this script launches more servers in the background.
#
# There are a few ways things can break:
#  (1) The server could shut down
#  (2) The socket file could be removed
#  (3) The symlinks in ~/.emacs.d/preload/ could be removed
#
# Also, any combination of the above three could happen.

# Note, only ever kills user's own servers.  Allowing root to manipulate servers for all users would be complicated.
# It's not very clean but if needed could do: for u in $users; do (su - $u; emacs-preload ...); done

#: ${EMACS_PRELOAD_SIZE:=3} # How many servers to keep preloaded
#: ${EMACS_PRELOAD_EMACS:=emacs} # `emacs` command
#: ${EMACS_PRELOAD_EMACSCLIENT:=emacsclient} # `emacsclient` command
#: ${EMACS_PRELOAD_LAUNCH_DELAY:=5} # How long to wait between starting servers
#: ${EMACS_PRELOAD_CONNECT_DELAY:=0.1} # How long to wait between connection attempts
#: ${EMACS_PRELOAD_CONNECT_ATTEMPTS:=600} # How many times to try connecting
#: ${EMACS_PRELOAD_PREFIX:="preload-"} # Unique prefix used for server names
#
## About 150ms delay if not already have these
##EMACS_PRELOAD_LINK_DIR=$HOME/.emacs.d/preload
##EMACS_PRELOAD_SOCKET_DIR=/tmp/emacs$UID
##    "~/.emacs.d/")
##       (format "%s/emacs%d" (or (getenv "TMPDIR") "/tmp") (user-uid)))

# TODO: Three parts
#   links
#   sockets
#   servers

# TODO: describe environment variables
ENV_PREFIX = 'EMACS_PRELOAD_'
def configs():
    # These two lines mirror code in Emacs's `server.el`
    link_dir = os.path.expanduser('~/.emacs.d/preload')
    socket_dir = or_none(os.getenv('TMPDIR'), '/tmp') + '/emacs' + str(os.geteuid())
    return [
        ('DRY_RUN', False, 'Print commands instead of executing them'),
        ('QUIET', False, 'Supress info messages and startup messages from emacs servers'),
        ('QUERY_EMACS', False, 'Call emacs to determine LINK_DIR and SOCKET_DIR.'
         + ' Off by default for performance.'),
        ('SIZE', ('SIZE', 5), 'Number of servers to keep running (see `start` and `stop`)'),
        ('EMACS', ('FILE', 'emacs'), 'The emacs binary to use'),
        ('EMACSCLIENT', ('FILE', 'emacsclient'), 'The emacsclient binary to use'),
        ('PS', ('FILE', 'ps'), 'The ps binary to use for process listing'),
        ('START_DELAY', 0.1, 'Seconds to wait between starting servers'),
        ('STOP_DELAY', 0.1, 'Seconds to wait between stopping servers'),
        ('CONNECT_DELAY', 0.1, 'Seconds between attempts to connect to a server'),
        ('CONNECT_ATTEMPTS', 100, 'Maximum number of attempts to connect to a server'),
        ('CONNECT_TIMEOUT', 10.0, 'Maximum seconds to keep attempting to connect to a server'),
        ('PREFIX', 'preload-', 'Prefix to use for server names, links, and sockets'),
        ('LINK_DIR', ('DIR', link_dir), 'Directory in which to place links'),
        ('SOCKET_DIR', ('DIR', socket_dir), 'The directory in which emacs stores its sockets')]

################
# Errors

class Err(Exception):
    def __init__(self, lineno, message):
        Exception.__init__(self)
        self.message = f('[#{}] {}', lineno, message)

def error(message, *args, **kwargs):
    raise Err(lineno(2), f(message, *args, **kwargs))

def check(val, message, *args, **kwargs):
    if val: return val
    else: raise Err(lineno(3), f(message, *args, **kwargs))

# TODO: lineno based on source file origin
def lineno(back): return traceback.extract_stack(limit=back)[0].lineno

def because(m1, m2): return f('{}\n    because {}', m1, m2)

@contextlib.contextmanager
def noop(): yield

@contextlib.contextmanager
def err(message, *args, **kwargs):
    lineno = traceback.extract_stack(limit=3)[0].lineno
    try: yield
    except Err as e:
        raise Err(lineno, because(f(message, *args, **kwargs), e.message))
    except Exception as e:
        (_, _, tb) = sys.exc_info()
        current = os.path.abspath(__file__)
        innermost = None
        for frame in traceback.extract_tb(tb): # innermost is last in list
            if current == os.path.abspath(frame.filename):
                innermost = frame.lineno
        raise Err(lineno, because(f(message, *args, **kwargs), Err(innermost, str(e)).message))

@contextlib.contextmanager
def warn(message, *args, **kwargs):
    try: yield
    except Exception as e:
        # TODO: to stderr
        log(because(f(message, *args, **kwargs), str(e)))

################
# Execution control

# Implements dry runs.  Calls fun(*args, **kwargs) if DRY_RUN is false.
# Otherwise, prints the function and arguments that would be called.
def dry(fun, *args, **kwargs):
    if DRY_RUN: log('skipping due to dry run: {} on {} with {}', fun.__name__, args, kwargs)
    else: fun(*args, **kwargs)

# Used by commands that cannot dry-run.  Throws error if DRY_RUN is true.
def not_dry(c):
    if DRY_RUN: error('Dry run not supported by {}', c)

# Run the process described by `args`
def cmd(*args, stdin=subprocess.DEVNULL, stdout=subprocess.PIPE, stderr=None, dry_run=False):
    if dry_run and DRY_RUN:
        log('skipping due to dry run: {}', ' '.join(map(shlex.quote, args)))
        return None
    else:
        # TODO: strange cmd errors
        with err('process failed: {}', ' '.join(map(shlex.quote, args))):
            r = subprocess.run(args,
                stdin=stdin, stdout=stdout, stderr=stderr, universal_newlines=True)
            r.check_returncode()
        return r.stdout

##################
# Generic helpers

# `None` aware `or`
def or_none(x, y): return x if x is not None else y

# Simulate f"..." strings for Python 3.5
def f(s, *args, **kwargs): return s.format(*args, **kwargs)

# Print a log message with the 'emacs-preload' prefix
def log(s, *args, **kwargs): print(f('emacs-preload: {}', f(s, *args, **kwargs)))

# Print info messages, but only if QUIET is false.
def info(s, *args, **kwargs):
    if not QUIET:
        log(s, *args, **kwargs)

# Parse strings as booleans
true_strings = ['y', 'yes', 't', 'true', 'on', '1']
false_strings = ['n', 'no', 'f', 'false', 'off', '0']
def parse_bool(value):
    # These true and false values mirror `distutils.util.strtobool`
    if isinstance(value, bool):
        return value
    elif value.lower() in true:
        return True
    elif value.lower() in false:
        return False
    else:
        error('invalid truth value \'{}\'\n'
            '        for True use one of {}\n'
            '        for False use one of {}\n'
            '        both are case insensitive',
            value, or_str(true), or_str(false))

# Combine `parts` according to English grammar rules
def or_str(parts, prefix='\'', postfix='\''):
    parts = [prefix+p+postfix for p in parts]
    if len(parts) == 0:
        error('TODO')
    elif len(parts) == 1:
        return parts[0]
    elif len(parts) == 2:
        return f('{} or {}', parts[0], parts[1])
    else:
        return ', '.join(parts[:len(parts)-1]) + ', or ' + parts[-1]

# Wrap lines to terminal width but recognize '\n\n' as a paragraph separator
def wrap_lines():
    # Taken from argparse.HelpFormatter.__init__
    # NOTE: COLUMNS is usually not set
    try: width = int(os.environ['COLUMNS'])
    except (KeyError, ValueError): width = 80
    width -= 2
    # Taken from argparse.HelpFormatter._format_text
    width = max(width, 11)

    def doc(d, *args, **kwargs):
        paragraphs = [textwrap.fill(re.sub('\s+', ' ', p.strip()), width)
            for p in f(d, *args, **kwargs).split('\n\n')]
        return '\n\n'.join(paragraphs)
    return doc

# Forces the arguments of ArgumentParser `c` to never be options
def literal_args(c):
    if len(c._actions) > 0:
        old_parse = c.parse_known_args
        def new_parse(args=None, namespace=None):
            return old_parse(['--']+or_none(args, []), namespace)
        c.parse_known_args = new_parse

# `DirEntry` returned by os.scandir are more trouble than they are worth, so
# just return the path
def scandir(path): return [p.path for p in os.scandir(path)]

# Return true if `socket` exists and is a socket
def is_socket(socket): return os.path.exists(socket) and stat.S_ISSOCK(os.stat(socket).st_mode)

# List the PID and command string of processes starting with `prefix`
def pgrep(prefix):
    with err('failed to get running processes'):
        with err('failed to get list of all processes'):
            output = cmd(PS, '-u', str(os.geteuid()), '-o', 'pid=,command=')
        for line in output.strip().split('\n'):
            with err('failed to parse process information line {}', line):
                [pid, proc] = line.split(maxsplit=1)
            if proc.startswith(prefix):
                yield (pid, proc)

######################
# Domain-specific helpers

# Evaluate an elisp expression
def elisp(code): return cmd(EMACS, '--batch', '--eval', code, stderr=subprocess.DEVNULL)

# Run `emacsclient` with a given socket
def emacs_cl(socket, *args, replace=False, **kwargs):
    args = [EMACSCLIENT, '--quiet', '--socket-name', socket] + list(args)
    if replace:
        os.execvp(EMACSCLIENT, args)
    else:
        return cmd(*args, **kwargs)

# Prefix that server processes start with in `ps`
def server_prefix(): return f('{} --daemon=', EMACS)

# Prefix striped from server processes in `ps` to get the socket name
def server_socket_prefix(): return f('{}{}', server_prefix(), SOCKET_DIR)

# Convert a link path to a socket path
def socket_from_link(path):
    with err('failed to follow link {}', path):
        return os.path.join(os.path.dirname(path), os.readlink(path))

# Generator that lists available preload links
def links(non_links=False):
    with err(f('failed to list preload links in ', LINK_DIR)):
        # NOTE: lazy generator because `claim_socket` needs only one
        for link in scandir(LINK_DIR):
            if os.path.basename(link).startswith(PREFIX):
                if non_links or os.path.islink(link):
                    yield link

# Returns number of available preload links
def link_count():
    with err('failed to count preload links'):
        return len(list(links()))

# Returns number of clients connected to the server at `socket`
def client_count(socket):
    with err('failed to determine client count'):
        with err('failed to connect to server at socket {}', socket):
            count_str = emacs_cl(socket, '--eval', '(princ (length server-clients))')
        with err('server returned non-integer count {}', count_str):
            count_int = int(count_str)
        return count_int - 1 # subtract one to not count ourselves

# Generator that lists available preload sockets
def sockets(non_sockets=False):
    with err(f('failed to list preload sockets in {}', SOCKET_DIR)):
        for socket in scandir(SOCKET_DIR):
            if os.path.basename(socket).startswith(PREFIX):
                if non_sockets or is_socket(socket):
                    yield socket

# Parse the `size` argument to `start` and `stop`
def preload_size(s, default):
    with err(f('failed to parse preload size `{}`', s)):
        if s is None:
            i = default
        elif re.fullmatch('\\+[0-9]+', s) is not None:
            i = link_count() + int(s[1:])
        elif re.fullmatch('\\-[0-9]+', s) is not None:
            i = link_count() - int(s[1:])
        elif re.fullmatch('[0-9]+', s) is not None:
            i = int(s)
        else:
            error('invalidly formatted size `{}`', s)

        if i >= 0: return i
        else:
            info('using zero instead of negative size {}', i)
            return 0

# Reserve a server and its socket for our use as a client
def claim_socket():
    with err('failed to claim a socket file'):
        files = links()
        try: link = next(files)
        except StopIteration as e:
            error('no links available in {}', LINK_DIR)
        socket = socket_from_link(link)
        try: dry(os.remove, link)
        except Exception as e:
            if os.path.exists(link):
                error(because(f('failed to remove link {}', link), str(e)))
            else:
                error(because(f('missing link {}', link), str(e)))
        return socket

################################
# Subcommands

# Check for errors in the current state
def check_status(args): status(args, verbose=False)

# Print server status
def status(args, verbose=True):
    client_prefix = f('{} --quiet --socket-name ', EMACSCLIENT)
    client_socket_prefix = f('{}{}', client_prefix, SOCKET_DIR)
    def print_status(string, expected_prefix, require_link=True):
        class _Err (Exception): pass
        def _check(test, message, *args, **kwargs):
            nonlocal errs
            if not test:
                print(f('!!! error: {}', f(message, *args, **kwargs)))
                errs += 1
                raise _Err()

        @contextlib.contextmanager
        def mute(message=None, *args, **kwargs):
            try: yield
            except _Err: pass

        @contextlib.contextmanager
        def _err(*args, **kwargs):
            try: yield
            except Exception: _check(False, *args, **kwargs)

        def _info(s, *args, **kwargs):
            if verbose:
                print(f(s, *args, **kwargs))

        if not string.startswith(f('{}/{}', expected_prefix, PREFIX)):
            _info('    warn: not recognized')
            print(f('status: ignored'))
            print()
            return

        # TODO: document code
        errs = 0
        name = string[len(expected_prefix + '/'):].split(' ')[0]

        link = os.path.abspath(os.path.join(LINK_DIR, name))
        socket = os.path.abspath(os.path.join(SOCKET_DIR, name))

        _info('    name: {}', name)

        # TODO: '--' but '+1' ?
        with mute():
            _check(name.startswith(PREFIX),
                'name does not match {}PREFIX ({}): {}', ENV_PREFIX, PREFIX, name)

            # Links
            with mute():
                # TODO: print link
                if not os.path.lexists(link):
                    _check(not require_link,
                        'link does not exist: {}', link)
                else:
                    _info('    link: {}', link)
                    _check(os.path.islink(link),
                        'file not a link: {}', link)
                    with _err('could not follow link: {}', link):
                        target = os.path.abspath(socket_from_link(link))
                    _check(socket == target,
                         'socket ({}) does not match link target ({})', socket, target)

            # Sockets
            with mute():
                _check(os.path.exists(socket),
                    'socket does not exist: {}', socket)
                _info('    socket: {}', socket)
                _check(is_socket(socket),
                    'file not a socket: {}', socket)

            # Servers
            with mute():
                server_string = f('{}{}/{}', server_prefix(), SOCKET_DIR, name)
                num_servers = 0
                for (pid, proc) in servers:
                    if proc.startswith(server_string):
                        _info('    server: pid {}: {}', pid, proc)
                        num_servers += 1
                _check(num_servers == 1,
                    '{} servers but expected 1', num_servers)

            with mute():
                with _err('failed to connect to server at {}', socket):
                    count_str = emacs_cl(socket, '--eval', '(princ (length server-clients))',
                        stderr=subprocess.DEVNULL)
                with _err('server returned non-integer count {}', count_str):
                    count_int = int(count_str)
                _info('    reported clients: {}', count_int - 1)

            # Clients
            client_string = client_prefix + socket
            for (pid, proc) in clients:
                if proc.startswith(client_string):
                    _info('    client: pid {}: {}', pid, proc)

        print(f('status: {} errors', errs))
        print()

    links = []
    with warn('failed to read link directory {}', LINK_DIR):
        links = list(scandir(LINK_DIR))

    sockets = []
    with warn('failed to read socket directory {}', SOCKET_DIR):
        sockets = list(scandir(SOCKET_DIR))

    servers = []
    with warn('failed to list servers'):
        servers = list(pgrep(server_prefix()))

    clients = []
    with warn('failed to list clients'):
        clients = list(pgrep(EMACSCLIENT))

    print('Configuration variables')
    print('------------------------')
    for (name, _, _) in configs():
        print(f('{}{}={}', ENV_PREFIX, name, shlex.quote(str(globals()[name]))))
    print()

    print(f('Links in {} ({})', LINK_DIR, len(links)))
    print('------------------------')
    for link in links:
        print(f('{}:', link))
        print_status(link, LINK_DIR)
    print()

    print(f('Sockets in {} ({})', SOCKET_DIR, len(sockets)))
    print('------------------------')
    for socket in sockets:
        print(f('{}:', socket))
        print_status(socket, SOCKET_DIR, require_link=False)
    print()

    print(f('Servers ({})', len(servers)))
    print('------------------------')
    for (pid, command) in servers:
        print(f('{}:', command))
        print_status(command, server_socket_prefix(), require_link=False)
    print()

    print(f('Clients ({})', len(clients)))
    print('------------------------')
    for (pid, command) in clients:
        print(f('pid {}: {}', pid, command))
        print_status(command, client_socket_prefix, require_link=False)
    print()

# Start emacs servers
def start(args):
    not_dry('start')
    init(args)
    size = preload_size(args.size, SIZE)
    while link_count() < size:
        info('creating server (have {}, want {})', link_count(), size)
        with err('failed to create socket file in {}', SOCKET_DIR):
            (fd, socket) = tempfile.mkstemp(dir=SOCKET_DIR, prefix=PREFIX)
            os.close(fd)
        with err('failed to create emacs server for socket file {}', socket):
            cmd(EMACS, '--daemon='+socket,
                stdout=subprocess.DEVNULL if QUIET else None,
                stderr=subprocess.DEVNULL if QUIET else None)
        with err('failed to create link from {} to socket {}', LINK_DIR, socket):
            os.symlink(socket, os.path.join(LINK_DIR, os.path.basename(socket)))
        # TODO: option for whether to patch
        # Patch the server to behave more like emacs instead of emacsclient
        with err('failed to patch emacs server'):
            emacs_cl(socket, '--eval', '''
                (progn
                    (require 'server)
                    ;; C-x C-c should actually kill emacs instead of just the client
                    (defun server-save-buffers-kill-terminal (arg)
                        (save-buffers-kill-emacs arg))
                    ;; Don't prompt user about clients when killing buffers
                    (remove-hook 'kill-buffer-query-functions
                        'server-kill-buffer-query-function)
                    ;; Don't prompt user about clients when killing emacs
                    (remove-hook 'kill-emacs-query-functions
                        'server-kill-emacs-query-function)
                    ;; Don't exit when all buffers closed.
                    ;; defun instead of remove-hook due to add-hook called on every buffer
                    (defun server-kill-buffer () nil)
                )''')
        time.sleep(START_DELAY)
    info('done creating servers (have {}, want {})', link_count(), size)

# Stop emacs servers
def stop(args):
    not_dry('stop')
    size = preload_size(args.size, 0)
    while link_count() > size:
        info('stopping server (have {}, want {})', link_count(), size)
        socket = claim_socket()
        with err('failed to send (kill-emacs) to server at {}', socket):
            emacs_cl(socket, '--eval', '(kill-emacs)')
        # Delay needed so servers after the first shutdown cleanly.
        # Though I don't know why.
        time.sleep(STOP_DELAY)
    info('done stopping servers (have {}, want {})', link_count(), size)

# Connect to a server
def connect(args):
    start_time = time.time()
    attempts = 0
    while True:
        attempts += 1
        elapsed_time = time.time() - start_time
        if attempts > CONNECT_ATTEMPTS:
            error('failed to connect after {} attempts', attempts)
        if elapsed_time > CONNECT_TIMEOUT:
            error('failed to connect after {} seconds', elapsed_time)
        try:
            socket = claim_socket()
        except Err as e:
            time.sleep(CONNECT_DELAY)
        else:
            with err('failed to set PWD on server at {}', socket):
                # TODO: anything other than PWD we need to set?
                # TODO: escape PWD
                # TODO: Note that `emacsclient --socket-name` accepts absolute paths
                # TODO: The default creates a frame, but this can (?) be overrided by passing `-nw`
                emacs_cl(socket, '--eval', f('(setenv "PWD" "{}")', os.getcwd()),
                    dry_run=True, stdout=subprocess.DEVNULL)
            with err('failed to connect to server at {}', socket):
                emacs_cl(socket, '--create-frame', *args.args,
                    replace=True, stdin=None, stdout=None, stderr=None, dry_run=True)
# TODO: connect to a specific server
# TODO: connect without removing link? (for debugging?)
# TODO: shorter retry limits
            sys.exit(0)

# Cleanup broken servers
def cleanup(args):
    socket_map = {}
    # Remove link if cannot connect or server already in use
    for link in links(non_links=True):
        if not os.path.islink(link):
            info('skipping non-link {}', link)
        else:
            try:
                socket = socket_from_link(link)
                clients = client_count(link)
                check(clients > 0,
                    'already in use by {} clients', clients)
                socket_map[socket.path] = link
            except Err as e:
                info(because(f('removing link {}', link), e.message))
                with err(f('failed to remove link {}', link)):
                    dry(os.remove, link)

    # Remove socket if no link and either cannot connect or no clients
    # currently connected
    for socket in sockets(non_sockets=True):
        if socket in socket_map:
            info('skipping socket {} due to having link {}', socket, socket_map[socket])
        elif not is_socket(socket):
            info('skipping non-socket {}', socket)
        else:
            try:
                clients = client_count(socket)
            except Err as e:
                info(because(
                    f('removing socket at {} due to no connection to the server', socket),
                    e.message))
                with err('failed to remove socket {}', socket):
                    dry(os.remove, socket)
            else:
                if clients == 0:
                    info('sending (kill-emacs) to server at {}'
                        ' due to having no link and no clients', socket)
                    with err('failed to (kill-emacs) on server at {}', socket):
                        emacs_cl(socket, '--eval', '(kill-emacs)', dry_run=True)
            # TODO: SIGTERM in cleanup?

# Kill running servers
def kill_servers(orphans_only, args):
    with err('failed to list servers'):
        servers = pgrep(f('{}/{}', server_socket_prefix(), PREFIX))
    for (pid, command) in servers:
        pid = int(pid)
        socket = command[len(server_prefix()):]
        if not orphans_only or not is_socket(socket):
            info('sending SIGKILL to emacs server (pid {}, socket {})', pid, socket)
            with err('failed to send SIGKILL to emacs server (pid {}, socket {})', pid, socket):
                dry(os.kill, pid, signal.SIGKILL)
# TODO: SIGTERM

# Combines `connect` with `start` in the background
def run(args):
    not_dry('run')
    # TODO: minor race condition means that number of servers remaining after
    # connect may be less by one (sometimes)
    if not hasattr(args, 'size'):
        args.size = None

    # Run `start` in a background process
    with err('failed to fork background process for `start`'):
        pid = os.fork()
    if pid == 0:
        with err('failed to create background process for `start`'):
            with err('failed to detach'):
                os.setsid() # Detach from the parent process and terminal
            with err('failed to fork'):
                pid = os.fork()
            if pid == 0:
                # TODO: set argv[0]
                with err('failed to change to root directory'):
                    os.chdir('/') # Avoid holding directories open
                globals()['QUIET'] = True # Silence everything except errors
                start(args)
            else:
                sys.exit(0)
    else:
        with err('failed waiting on child process for `start`'):
            os.waitpid(pid, 0) # Avoid zombie process from outer fork
        connect(args)

# Create the directory for links to servers
def init(args):
    with err('failed to create preload link directory {}', LINK_DIR):
        dry(os.makedirs, LINK_DIR, exist_ok=True)

################
# Initialization and driver

# Parse command-line arguments
def parse_args():
    ################################
    # Constants

    doc = wrap_lines()

    args_help = f('''Arguments to `emacsclient`.  Not parsed by `emacs-preload`.  Passed unchanged to `emacsclient`.''')

    def size_help(size):
        return f('''Target number of servers to have running.  Defaults to {} if omitted.
            Relative when starts with `+` or `-`.  Absolute otherwise.''', size)

    cleanup_doc = '''Normally emacs-preload cleans up after itself automatically.  If it
            doesn't, you can use this command to manually cleanup.  We are
            working to reduce how often this command is needed.'''

    def kill_doc(servers, commands):
        return f('''{}

            WARNING: Disconnects any `emacsclient` connected to {} preload
            servers.  This is not part of `stop` or `cleanup` since there is
            no way to tell if the servers skipped by `cleanup` have connected
            clients.  This command should only be used when {} to fail to
            shutdown a server.''',
            cleanup_doc, servers, commands)

    ################################
    # Argument parser

    # NOTE: we do not support the '@file' convention because arguments to
    #     subcommand must be passed unchanged.  Thus no
    #     `fromfile_prefix_chars` argument to `ArgumentParser`
    p = argparse.ArgumentParser(usage='%(prog)s [options] <subcommand> ...',
        add_help=False, formatter_class=argparse.RawDescriptionHelpFormatter,
        description=doc('''TODO description

            TODO: TL;DR basic usage

            TODO: Environment variables (help subcommand?)
            Booleans # True values are 'y', 'yes', 't', 'true', 'on', and '1';
                    # false values are 'n', 'no', 'f', 'false', 'off', and '0'


            TODO: flags must be before sub-command
            '''))

    ################################
    # Options
    p.add_argument('-h', '--help', action='help', help='Show this help message and exit')
    c = p.add_argument('-v', '--version', action='version',
        version=f('emacs-preload version {}', __version__),
        help='Show program\'s version number and exit')
    for (key, default_value, documentation) in configs():
        # TODO
        if isinstance(default_value, tuple): # Extract the manually defined metavar is there is any
            metavar = default_value[0]
            value = default_value[1]
        else: # Otherwise, name the metavar after the type
            metavar = type(default_value).__name__.upper()
            value = default_value

        # Determine default value and add to documentation
        env_value = os.getenv(f('{}{}', ENV_PREFIX, key))
        if env_value is None:
            # Environment does not override default
            documentation += f(' (default {})', value)
        else:
            # Environment does override default
            documentation += f(' (default {} but environment overrides to \'{}\')', value, env_value)
            value = env_value

        name=key.lower().replace('_', '-')
        # Simple Boolean flags
        if isinstance(default_value, bool):
            p.add_argument(f('--{}', name), default=value, action='store_true', dest=key, help=documentation)
            p.add_argument(f('--no-{}', name), default=value, action='store_false',
                dest=key, help=f('Disable --{}', name))
        # Options with arguments
        else:
            p.add_argument(f('--{}', name), metavar=metavar, action='store', dest=key,
                default=value, help=documentation)

    ################################
    # Subcommands
    s = p.add_subparsers(title='subcommands', dest='subcommand')
    s.required = True # Workaround for bug in `argparse` (as of Python 3.5)
    subcommands=collections.OrderedDict() # OrderedDict so printed in a consistent order

    def subcommand(func, name=None, description=None, *args, **kwargs):
        if name is None:
            name = func.__name__
        name = name.replace('_', '-')

        c = s.add_parser(name, prog=f('emacs-preload [options] {}', name), description=description,
            add_help=False, formatter_class=argparse.RawDescriptionHelpFormatter, *args, **kwargs)
        c.set_defaults(action=func)
        subcommands[name] = c
        return c

    c = subcommand(run,
        help='''Main `emacs-preload` subcommand.  Connect to a preload server and in the
            background start new servers.''',
        description=doc('''Main `emacs-preload` subcommand. Uses `connect` to connect to an available
            preload server, while using `start` in the background to launch new servers.'''))
    c.add_argument('args', nargs='*', help=args_help)

    c = subcommand(check_status, name='check', help='Check for errors',
        description=doc('''Print preload configuration and check for errors in links, sockets, servers, or clients.'''))

    c = subcommand(start, help='Start preload servers',
        description=doc('''Start new preload servers until at least `size` servers are running.'''))
    c.add_argument('size', nargs='?', help=size_help(f('the value of SIZE')))

    c = subcommand(stop, help='Stop preload servers',
        description=doc('''Stop running preload servers until at most `size` servers are running.'''))
    c.add_argument('size', nargs='?', help=size_help(f('zero')))

    c = subcommand(status, help='Print preload status',
        description=doc('''Print status of preload configuration, links, sockets, servers, and clients.'''))

    c = subcommand(init, help='Create the directory holding links to preload servers',
        description=doc('''Create the directory specified by LINK_DIR, which is where links to
            preload servers are kept.

            Rarely needs to be called manually as it is automatically called
            by the subcommands that need the LINK_DIR directory.'''))

    c = subcommand(connect, help='Connect to a preload server',
        description=doc('''Connect to an available preload server.  Picks a waiting server from those
            in LINK_DIR, removes it from LINK_DIR, and connects to it with `emacsclient`.'''))
    c.add_argument('args', nargs='*', help=args_help)

    c = subcommand(cleanup, help='Cleanup broken servers',
        description=doc('''Cleanup broken servers.

            {}

            This command is always safe.  It will not close servers with
            connected clients or fresh servers waiting for a client.  Because
            this subcommand is guaranteed to be safe, it leaves alone servers
            for which it cannot confirm that there are no clients.  Thus you
            may need to use kill-orphans or kill-all subcommands to kill such
            servers.

            Removes links in LINK_DIR for unreachable servers and servers that
            already have clients.  Removes sockets in SOCKET_DIR that do not
            connect to a server.  Sends `(kill-emacs)` to servers that have no
            client and are not in LINK_DIR.''', cleanup_doc))


    c = subcommand(functools.partial(kill_servers, True), name='kill-orphans', help='Kill orphaned servers',
        description=doc('''Kills all orphan preload servers, which are those for which there are no sockets in
            SOCKET_DIR.

            {}''', kill_doc('orphan', '`cleanup`')))

    c = subcommand(functools.partial(kill_servers, False), name='kill-all', help='Kill all servers',
        description=doc('''Kills all preload servers.

            {}''', kill_doc('', '`cleanup` and `kill-orphans`')))

    # TODO: `doc` wiki export
    # TODO: readme
    # TODO: connect-only

    def help(args):
        if args.subcommand is None:
            subcommands['help'].print_help()
        elif args.subcommand in subcommands:
            subcommands[args.subcommand].print_help()
        else:
            error('no subcommand {}. ', args.subcommand)

    # Last so we can get a list of all subcommands
    c = subcommand(help, help='Prints help for subcommands', description=doc('''Prints help for the given subcommand'''))
    c.add_argument('subcommand', metavar='subcommand', nargs='?', choices=subcommands.keys(), action='store',
        help=f('The subcommand for which to print help (choose from {})', or_str(subcommands.keys())))

    ################################
    # Subcommand arguments

    # Arguments to subcommand should not be interpreted because `connect` and
    # `run` pass them on to `emacsclient`.  Last so we get list of all
    # subcommands
    for c in subcommands.values(): literal_args(c)

    return p.parse_args()

def main():
    try:
        # Parse command line
        args = parse_args()

        # Initialize global variables
        # TODO: parse
        for (key, default_value, _) in configs():
            if isinstance(default_value, tuple):
                default_value = default_value[1]
            value = vars(args)[key]
            # TODO: document bool parsing
            with err('could not parse {}: {}', key, value):
                globals()[key] = parse_bool(value) if isinstance(default_value, bool) else type(default_value)(value)

        if QUERY_EMACS:
            with err('failed to query emacs for LINK_DIR'):
                globals()['LINK_DIR'] = elisp(
                    '(princ (expand-file-name (locate-user-emacs-file "preload")))')
            with err('failed to query emacs for SOCKET_DIR'):
                globals()['SOCKET_DIR'] = elisp(
                    '(progn (require \'server) (princ (expand-file-name server-socket-dir)))')

        # Run the selected subcommand
        args.action(args)

    # Catch only Err exceptions.  Other exceptions are bugs, so we leave them uncaught.
    except Err as e:
        log(e.message)
        # TODO: with stderr
        sys.exit(1)
    sys.exit(0)

if __name__ == '__main__':
    main()

################
# Development notes

# Self contained:
#  - No installation needed
#  - No third party libraries needed
# Cross platform:
#  - Linux
#  - MacOS
#  - Maybe Windows (if someone wants to port it)
#    - Could need `ps`
# Performance:
#  - Startup should be below human perception threshold
#  - Prefer library methods over spawning processes
# Safety:
# Don't capitalize errors (they must be compatable with `because`
#  - TODO
# Capitalize all documentation
# Indent four columns (even for wrapped statements)
# Error message numbers are line numbers

# - Linters:
#   + pylint
#   + pycodestyle
#   + pydocstyle
#   + flake8
